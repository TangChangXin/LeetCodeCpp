//
// Created by XKA on 2021/6/17.
//

/*
 * 前序遍历 preorder = [3,9,20,15,7]
 * 中序遍历 inorder = [9,3,15,20,7]
 * 还原的二叉树
    3
   / \
  9  20
    /  \
   15   7
 */


#include <vector>
#include <stack>
#include "Tree_lc94.cpp"

class Solution105 {
public:
    TreeNode *buildTree(vector<int> &preorder, vector<int> &inorder) {

        return g构造树(preorder, 0, preorder.size()-1, inorder, 0, inorder.size()-1);
    }

    //算法小抄方法，实质和官方递归一样
    TreeNode *g构造树(vector<int> &q前序数组, int q前序起点, int q前序终点,vector<int> &z中序数组, int z中序起点, int z中序终点) {
        //“q前序终点-q前序起点”等于“z中序终点-z中序起点”，所以判断一个就行了。相等时后序语句可以正常执行，注意与889区别
        if (q前序起点 > q前序终点) return nullptr;

        int g根节点值 = q前序数组[q前序起点];
        int g根节点位置 = z中序起点;//根节点在中序遍历中位置
        while (g根节点值 != z中序数组[g根节点位置])
            g根节点位置++;

        TreeNode *g根节点 =new TreeNode(g根节点值);
        //注意边界条件的计算，左子树或者右子树在前序数组和中序数组中的元素个数是一样的，实际关注左子树的终点如何计算即可
        g根节点->left = g构造树(q前序数组, q前序起点+1, g根节点位置-z中序起点+q前序起点, z中序数组, z中序起点, g根节点位置-1);
        g根节点->right = g构造树(q前序数组, g根节点位置-z中序起点+q前序起点+1, q前序终点, z中序数组, g根节点位置+1, z中序终点);
        return g根节点;
    }

/*
 * 算法
我们归纳出上述例子中的算法流程：
1.我们用一个栈和一个指针辅助进行二叉树的构造。初始时栈中存放了根节点（前序遍历的第一个节点），指针指向中序遍历的第一个节点
2.我们依次枚举前序遍历中除了第一个节点以外的每个节点。如果 index 恰好指向栈顶节点，那么我们不断地弹出栈顶节点并向右移动 index，并将当前节点作为最后一个弹出的节点的右儿子
如果 index 和栈顶节点不同，我们将当前节点作为栈顶节点的左儿子；
3.无论是哪一种情况，我们最后都将当前的节点入栈。
最后得到的二叉树即为答案。

 preorder = [3, 9, 8, 5, 4, 10, 20, 15, 7]  根左右
 inorder =  [4, 5, 8, 10, 9, 3, 15, 20, 7]  左根右

 */
    TreeNode *迭代法(vector<int>& q前序数组, vector<int>& z中序数组){
        if (q前序数组.size() == 0) return nullptr;

        TreeNode *g根节点 = new TreeNode(q前序数组[0]);
        stack<TreeNode*> z节点暂存栈;
        z节点暂存栈.push(g根节点);//首先将根节点入栈，并在后面先以根节点为当前节点
        //下方的变量对应的节点是「当前节点不断往左走达到的最终节点」。即以前序数组中的当前节点为根节点不断向左遍历
        int z最左节点位置 = 0;
        for (int i = 1; i < q前序数组.size(); ++i) {
            //注意“q前序数组[i]”和当前节点的关系
            int q前序节点值 = q前序数组[i];//该变量保存的是前序数组中当前节点的后面一个节点的值，在构造新的左子节点或者右子结点时，用这个值进行初始化

            TreeNode *d当前节点 = z节点暂存栈.top();//比较当前栈顶值和中序数组值
            if (d当前节点->val != z中序数组[z最左节点位置]){
                //两者如果不相等说明，在前序数组中当前节点的后面一个节点必是当前节点的左子节点，可以结合图像用反证法证明它不是右子节点。
                d当前节点->left =new TreeNode(q前序节点值);
                z节点暂存栈.push(d当前节点->left);
            }

            else{
                //相等说明前序数组中当前节点的后面节点是栈中某个节点的右子节点。仔细思考下方的判断条件
                //如果栈空了，那么说明根节点弹出了，那么此时前序数组中的“q前序数组[i]”值一定是右子节点
                while (!z节点暂存栈.empty() && z节点暂存栈.top()->val == z中序数组[z最左节点位置]){
                    //如果“z节点暂存栈.top()->val == z中序数组[z最左节点位置]”判断不相等，说明“z中序数组[z最左节点位置]”是上一次弹出的栈顶的右子节点
                    d当前节点 = z节点暂存栈.top();
                    z节点暂存栈.pop();
                    ++z最左节点位置;
                }
                //d当前节点
                d当前节点->right =new TreeNode(q前序节点值);
                z节点暂存栈.push(d当前节点->right);
            }
        }
        return g根节点;
    }
};