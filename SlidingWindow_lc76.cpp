//
// Created by XKA on 2021/7/12.
//

//困难 最小覆盖子串
#include <iostream>
#include <string>
#include <unordered_map>

using namespace std;

class Solution76 {
public:
    //s是源字符串，t是目标字符串
    string minWindow(string s, string t) {
        unordered_map<char, int> t统计, c窗口;//unordered_map不允许键重复
        for (char c : t) t统计[c]++;//初始化为1，因为源字符串中的子串只要保证目标字符串中的字符只出现一次就行了，方便后面滑动窗口的时候进行比较
        int z左边界 = 0, y右边界 = 0;//初始化滑动窗口的左右边界
        //因为这题子串好像无重复所以这样定义
        //标志表示目标字符中的字符在窗口中的存在性，不表示数量。标志为1表示窗口中存在1种目标字符，标志为2表示窗口中存在2种目标字符，标志为3表示窗口中存在3种目标字符
        int b标志 = 0;
        int q起点 = 0, c长度 = INT_MAX;//起点是最终输出的子串在源串中的位置。长度初始化为一个很大的值，然后不断比较取最小的值

        while (y右边界 < s.size()) {
            char j加入窗口的字符 = s[y右边界];
            ++y右边界;//右移窗口
            //更新窗口内的数据？
            if (t统计.count(j加入窗口的字符)) {
                //如果“t统计”存在“加入窗口的字符”，count返回1，否则返回0
                //如果“目标字符串”中包含“加入窗口的字符”，那么窗口中对应的字符的值就加1。窗口滑动的过程中可能导致字符的值大于1
                ++c窗口[j加入窗口的字符];
                //“c窗口[j加入窗口的字符]”大于1的时候，标志不用增加了，标志描述的是存在性，之前等于1的时候已经增加过了，说明字符已经存在了
                if (c窗口[j加入窗口的字符] == t统计[j加入窗口的字符]) ++b标志;
            }

            while (b标志 == t统计.size()) {
                //这里保证子串最短。新子串的长度小于之前子串的长度才会才用新的左边界作为起点，否则还是保留以前的起点
                if (y右边界 - z左边界 < c长度) {
                    q起点 = z左边界;
                    c长度 = y右边界 - z左边界;
                }
                //当前窗口中已经包含了目标字符串中的所有字符，开始收缩窗口左边界
                //TODO 注意：开始写的“c窗口[z左边界]”，运行时间超时。接下面
                // 窗口的键是字符，左边界是数字，但是窗口中没有对应的数字作为键，这样会创建一个键，且默认值是0。所以程序逻辑没错，但是实际跑的时候有错
                char y移出窗口字符 = s[z左边界];

                ++z左边界;
                if (t统计.count(y移出窗口字符)) {
//                    --c窗口[y移出窗口字符];//放在这里。假设放在这里，如果“c窗口[y移出窗口字符]”本来就是1的话，减完了就是0，下面的if判断不会执行，情况是错误的
                    if (c窗口[y移出窗口字符] == t统计[y移出窗口字符]) --b标志;
                    --c窗口[y移出窗口字符];//应该放在这里。
                }
            }
        }
        //没找到返回空字符串
        return c长度 == INT_MAX ? "" : s.substr(q起点, c长度);
    }
};

int main() {
    unordered_map<char, int> atest;
    string s = "123456722";
    for (char c : s) ++atest[c];
//    cout << atest.count('2') << endl;
    cout << atest['2'];
//    printf("%d\n", atest.count('0'));

//    char a1 = 'a';
//    cout << a1 << endl;
//    printf("%d\n",a1);
//    cout << a1+1 << endl;
    return 0;
}